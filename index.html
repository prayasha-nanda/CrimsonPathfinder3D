<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="death_star_icon.svg" type="image/svg+xml">
    <title>Crimson Pathfinder 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            background-color: #1a0000;
            color: #f00;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .container {
            background-color: #0d0000;
            border: 2px solid #8b0000;
            border-radius: 1rem;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-width: 95vw;
            max-height: 95vh;
            overflow: auto;
        }

        .maze-display-area {
            display: flex;
            flex-direction: row;
            gap: 1.5rem;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
        }

        #threejsContainer {
            display: block;
            border-radius: 0.5rem;
            touch-action: none;
            background-color: #000;
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1/1;
            border: 1px solid #8b0000;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            background-color: rgba(139, 0, 0, 0.7);
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 1px solid #ff0000;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .zoom-btn:hover {
            background-color: rgba(255, 0, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        .zoom-btn:disabled {
            background-color: rgba(51, 0, 0, 0.5);
            color: rgba(102, 0, 0, 0.7);
            cursor: not-allowed;
            box-shadow: none;
        }

        #miniMapContainer {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid #8b0000;
            border-radius: 0.5rem;
            padding: 0.5rem;
            background-color: #0d0000;
            flex-shrink: 0;
        }

        #miniMapCanvas {
            background-color: #000;
            display: block;
            border-radius: 0.25rem;
            width: 200px;
            height: 200px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            width: 100%;
        }

        .btn {
            background-color: #8b0000;
            color: #fff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.3);
        }

        .btn:hover {
            background-color: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
        }

        .btn:disabled {
            background-color: #330000;
            color: #660000;
            cursor: not-allowed;
            box-shadow: none;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group label {
            color: #ff4500;
            font-weight: bold;
        }

        .input-group input[type="number"] {
            background-color: #330000;
            border: 1px solid #ff0000;
            color: #fff;
            padding: 0.5rem;
            border-radius: 0.375rem;
            width: 6rem;
            text-align: center;
        }

        .status-message {
            color: #ff4500;
            font-weight: bold;
            min-height: 1.5rem;
        }

        @media (max-width: 1024px) {
            .maze-display-area {
                flex-direction: column;
                align-items: center;
            }
            #threejsContainer {
                max-width: 90vw;
            }
            #miniMapContainer {
                width: 100%;
                align-items: center;
            }
            #miniMapCanvas {
                width: 200px;
                height: 200px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .btn {
                width: 100%;
            }
            .input-group {
                flex-direction: row;
                justify-content: space-between;
                width: 100%;
            }
            .input-group input[type="number"] {
                width: 4rem;
            }
        }
    </style>
</head>
<body class="bg-red-950 text-red-500 flex justify-center items-center min-h-screen p-4">
    <div class="container">
        <h1 class="text-3xl font-extrabold text-red-400 mb-4 text-center">Crimson Pathfinder 3D, an AI Maze Solver</h1>
        <div class="maze-display-area">
            <div id="threejsContainer">
                <div class="zoom-controls">
                    <button id="zoomInBtn" class="zoom-btn">+</button>
                    <button id="zoomOutBtn" class="zoom-btn">-</button>
                </div>
            </div>
            <div id="miniMapContainer">
                <h2 class="text-xl font-bold text-red-400">Mini-Map</h2>
                <canvas id="miniMapCanvas"></canvas>
            </div>
        </div>
        <div class="controls">
            <div class="input-group">
                <label for="mazeCols">Columns:</label>
                <input type="number" id="mazeCols" value="20" min="5" max="30">
            </div>
            <div class="input-group">
                <label for="mazeRows">Rows:</label>
                <input type="number" id="mazeRows" value="20" min="5" max="30">
            </div>
            <button id="generateBtn" class="btn">Generate Maze</button>
            <button id="solveBtn" class="btn" disabled>Solve Maze</button>
            <button id="stopBtn" class="btn" disabled>Stop</button>
        </div>
        <p id="statusMessage" class="status-message text-red-400 text-center"></p>
    </div>

    <script type="module">
        let scene, camera, renderer, controls;
        const threejsContainer = document.getElementById('threejsContainer');

        const miniMapCanvas = document.getElementById('miniMapCanvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        let miniMapW;

        let cols = parseInt(document.getElementById('mazeCols').value);
        let rows = parseInt(document.getElementById('mazeRows').value);
        const WALL_HEIGHT = 10;
        const CELL_SIZE = 10;
        const WALL_THICKNESS = 1;

        let grid = [];
        let startNode, endNode;
        let openSet = [];
        let closedSet = [];
        let path = [];
        let solving = false;
        let solverInterval = null;
        let groguCell = null;

        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x660000, emissive: 0x220000 });
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
        const visitedMaterial = new THREE.MeshLambertMaterial({ color: 0x990000, transparent: true, opacity: 0.4 });
        const openSetMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });

        let xWingMesh;
        let deathStarMesh;
        let groguMesh;
        let mazeLights = [];

        let particleSystem = null;
        const PARTICLE_COUNT = 2000;
        const PARTICLE_SIZE = 2.5;
        const PARTICLE_SPEED = 0.02;
        const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        const particleAlphas = new Float32Array(PARTICLE_COUNT);
        const particleOffsets = new Float32Array(PARTICLE_COUNT);
        const particleColors = new Float32Array(PARTICLE_COUNT * 3);

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xFFD700) },
                pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') }
            },
            vertexShader: `
                attribute float alpha;
                attribute float pOffset; // Particle's offset along the path
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    gl_PointSize = ${PARTICLE_SIZE} * ( 300.0 / -mvPosition.z ); // Scale size with distance
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform sampler2D pointTexture;
                varying float vAlpha;
                void main() {
                    gl_FragColor = vec4( color, vAlpha * texture2D( pointTexture, gl_PointCoord ).a );
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = {
                    top: true,
                    right: true,
                    bottom: true,
                    left: true
                };
                this.visited = false;
                this.parent = undefined;

                this.g = Infinity;
                this.h = 0;
                this.f = Infinity;

                this.floorMesh = null;
                this.wallMeshes = {};
            }

            createMeshes() {
                const floorGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_THICKNESS, CELL_SIZE);
                this.floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                this.floorMesh.position.set(
                    this.x * CELL_SIZE + CELL_SIZE / 2,
                    -WALL_THICKNESS / 2,
                    this.y * CELL_SIZE + CELL_SIZE / 2
                );
                scene.add(this.floorMesh);

                const wallGeometry = new THREE.BoxGeometry(CELL_SIZE + WALL_THICKNESS, WALL_HEIGHT, WALL_THICKNESS);
                const sideWallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, CELL_SIZE + WALL_THICKNESS);

                this.wallMeshes.top = new THREE.Mesh(wallGeometry, wallMaterial);
                this.wallMeshes.top.position.set(this.x * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, this.y * CELL_SIZE);
                scene.add(this.wallMeshes.top);

                this.wallMeshes.right = new THREE.Mesh(sideWallGeometry, wallMaterial);
                this.wallMeshes.right.position.set(this.x * CELL_SIZE + CELL_SIZE, WALL_HEIGHT / 2, this.y * CELL_SIZE + CELL_SIZE / 2);
                scene.add(this.wallMeshes.right);

                this.wallMeshes.bottom = new THREE.Mesh(wallGeometry, wallMaterial);
                this.wallMeshes.bottom.position.set(this.x * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, this.y * CELL_SIZE + CELL_SIZE);
                scene.add(this.wallMeshes.bottom);

                this.wallMeshes.left = new THREE.Mesh(sideWallGeometry, wallMaterial);
                this.wallMeshes.left.position.set(this.x * CELL_SIZE, WALL_HEIGHT / 2, this.y * CELL_SIZE + CELL_SIZE / 2);
                scene.add(this.wallMeshes.left);
            }

            removeWallMesh(wallKey) {
                if (this.wallMeshes[wallKey]) {
                    scene.remove(this.wallMeshes[wallKey]);
                    this.wallMeshes[wallKey].geometry.dispose();
                    this.wallMeshes[wallKey].material.dispose();
                    this.wallMeshes[wallKey] = null;
                }
            }

            setFloorMaterial(material) {
                if (this.floorMesh) {
                    this.floorMesh.material = material;
                }
            }

            getUnvisitedNeighbors() {
                let neighbors = [];
                if (this.y > 0 && !grid[this.x][this.y - 1].visited) {
                    neighbors.push(grid[this.x][this.y - 1]);
                }
                if (this.x < cols - 1 && !grid[this.x + 1][this.y].visited) {
                    neighbors.push(grid[this.x + 1][this.y]);
                }
                if (this.y < rows - 1 && !grid[this.x][this.y + 1].visited) {
                    neighbors.push(grid[this.x][this.y + 1]);
                }
                if (this.x > 0 && !grid[this.x - 1][this.y].visited) {
                    neighbors.push(grid[this.x - 1][this.y]);
                }
                if (neighbors.length > 0) {
                    let r = Math.floor(Math.random() * neighbors.length);
                    return neighbors[r];
                } else {
                    return undefined;
                }
            }

            getValidNeighbors() {
                let neighbors = [];
                if (this.y > 0 && !this.walls.top) {
                    neighbors.push(grid[this.x][this.y - 1]);
                }
                if (this.x < cols - 1 && !this.walls.right) {
                    neighbors.push(grid[this.x + 1][this.y]);
                }
                if (this.y < rows - 1 && !this.walls.bottom) {
                    neighbors.push(grid[this.x][this.y + 1]);
                }
                if (this.x > 0 && !this.walls.left) {
                    neighbors.push(grid[this.x - 1][this.y]);
                }
                return neighbors;
            }
        }

        function removeWalls(a, b) {
            let x = a.x - b.x;
            if (x === 1) {
                a.walls.left = false;
                b.walls.right = false;
                a.removeWallMesh('left');
                b.removeWallMesh('right');
            } else if (x === -1) {
                a.walls.right = false;
                b.walls.left = false;
                a.removeWallMesh('right');
                b.removeWallMesh('left');
            }
            let y = a.y - b.y;
            if (y === 1) {
                a.walls.top = false;
                b.walls.bottom = false;
                a.removeWallMesh('top');
                b.removeWallMesh('bottom');
            } else if (y === -1) {
                a.walls.bottom = false;
                b.walls.top = false;
                a.removeWallMesh('bottom');
                b.removeWallMesh('top');
            }
        }

        function setupMaze3D() {
            if (scene) {
                while (scene.children.length > 0) {
                    const obj = scene.children[0];
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                }
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a0000);

            const aspectRatio = threejsContainer.clientWidth / threejsContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.set(
                cols * CELL_SIZE / 2,
                Math.max(cols, rows) * CELL_SIZE * 1.5,
                rows * CELL_SIZE / 2
            );
            camera.lookAt(cols * CELL_SIZE / 2, 0, rows * CELL_SIZE / 2);

            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(threejsContainer.clientWidth, threejsContainer.clientHeight);
                threejsContainer.appendChild(renderer.domElement);
            } else {
                renderer.setSize(threejsContainer.clientWidth, threejsContainer.clientHeight);
            }
            renderer.outputEncoding = THREE.sRGBEncoding;

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = CELL_SIZE * 2;
            controls.maxDistance = Math.max(cols, rows) * CELL_SIZE * 3;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            cols = parseInt(document.getElementById('mazeCols').value);
            rows = parseInt(document.getElementById('mazeRows').value);

            grid = [];
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    const cell = new Cell(i, j);
                    cell.createMeshes();
                    grid[i][j] = cell;
                }
            }

            const mazeOffsetX = -(cols * CELL_SIZE) / 2;
            const mazeOffsetY = -(rows * CELL_SIZE) / 2;
            scene.traverse((object) => {
                if (object.isMesh) {
                    object.position.x += mazeOffsetX;
                    object.position.z += mazeOffsetY;
                }
            });
            camera.position.x += mazeOffsetX;
            camera.position.z += mazeOffsetY;
            controls.target.set(mazeOffsetX + (cols * CELL_SIZE) / 2, 0, mazeOffsetY + (rows * CELL_SIZE) / 2);

            openSet = [];
            closedSet = [];
            path = [];
            solving = false;
            clearInterval(solverInterval);

            startNode = grid[0][0];
            endNode = grid[cols - 1][rows - 1];

            // X-Wing (Start Node Marker)
            const xWingGroup = new THREE.Group();
            const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x005500 }); // Green glow
            const wingThickness = CELL_SIZE * 0.1;
            const wingLength = CELL_SIZE * 0.8;

            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(wingLength * 0.2, wingThickness, wingLength * 0.2), wingMaterial);
            xWingGroup.add(body);

            // Wings
            const wing1 = new THREE.Mesh(new THREE.BoxGeometry(wingLength, wingThickness, wingThickness), wingMaterial);
            wing1.position.set(0, 0, 0);
            xWingGroup.add(wing1);

            const wing2 = new THREE.Mesh(new THREE.BoxGeometry(wingLength, wingThickness, wingThickness), wingMaterial);
            wing2.rotation.y = Math.PI / 2;
            xWingGroup.add(wing2);

            xWingMesh = xWingGroup;
            xWingMesh.position.set(
                startNode.x * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX,
                WALL_HEIGHT / 2 + WALL_THICKNESS * 2,
                startNode.y * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY
            );
            scene.add(xWingMesh);

            // Death Star (End Node Marker)
            const deathStarGroup = new THREE.Group();
            const sphereGeometry = new THREE.SphereGeometry(CELL_SIZE * 0.4, 32, 32);
            const dishGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.2, CELL_SIZE * 0.1, CELL_SIZE * 0.1); // Simplified dish
            const deathStarMaterial = new THREE.MeshLambertMaterial({ color: 0x808080, emissive: 0x303030 }); // Grey
            const dishMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF, emissive: 0x0000AA }); // Blue laser dish

            const sphere = new THREE.Mesh(sphereGeometry, deathStarMaterial);
            deathStarGroup.add(sphere);

            const dish = new THREE.Mesh(dishGeometry, dishMaterial);
            dish.position.set(CELL_SIZE * 0.3, 0, 0); // Position on the side of the sphere
            dish.rotation.y = Math.PI / 2; // Rotate to face outward
            deathStarGroup.add(dish);

            deathStarMesh = deathStarGroup;
            deathStarMesh.position.set(
                endNode.x * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX,
                WALL_HEIGHT / 2 + WALL_THICKNESS * 2, // Slightly higher than path
                endNode.y * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY
            );
            scene.add(deathStarMesh);

            // --- Baby Yoda (Grogu) Easter Egg ---
            // Remove previous Grogu if exists
            if (groguMesh) {
                scene.remove(groguMesh);
                groguMesh.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                groguMesh = null;
            }

            // Create Grogu
            const groguGroup = new THREE.Group();
            const skinMaterial = new THREE.MeshLambertMaterial({ color: 0x739D69, emissive: 0x304020 }); // Green skin
            const robeMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513, emissive: 0x301000 }); // Brown robes
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // Black eyes

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(CELL_SIZE * 0.15, 16, 16), skinMaterial);
            head.position.y = CELL_SIZE * 0.1; // Lift head slightly
            groguGroup.add(head);

            // Body (robe)
            const bodyRobe = new THREE.Mesh(new THREE.CylinderGeometry(CELL_SIZE * 0.2, CELL_SIZE * 0.25, CELL_SIZE * 0.3, 16), robeMaterial);
            bodyRobe.position.y = -CELL_SIZE * 0.1; // Position below head
            groguGroup.add(bodyRobe);

            // Ears
            const earGeometry = new THREE.ConeGeometry(CELL_SIZE * 0.08, CELL_SIZE * 0.3, 4);
            const ear1 = new THREE.Mesh(earGeometry, skinMaterial);
            ear1.rotation.z = -Math.PI / 2 + 0.5; // Rotate to be horizontal and slightly angled
            ear1.position.set(-CELL_SIZE * 0.15, CELL_SIZE * 0.15, 0);
            groguGroup.add(ear1);

            const ear2 = new THREE.Mesh(earGeometry, skinMaterial);
            ear2.rotation.z = Math.PI / 2 - 0.5;
            ear2.position.set(CELL_SIZE * 0.15, CELL_SIZE * 0.15, 0);
            groguGroup.add(ear2);

            // Eyes (simple spheres)
            const eyeGeometry = new THREE.SphereGeometry(CELL_SIZE * 0.03, 8, 8);
            const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye1.position.set(-CELL_SIZE * 0.05, CELL_SIZE * 0.15, CELL_SIZE * 0.12);
            groguGroup.add(eye1);

            const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye2.position.set(CELL_SIZE * 0.05, CELL_SIZE * 0.15, CELL_SIZE * 0.12);
            groguGroup.add(eye2);

            groguMesh = groguGroup;
            groguMesh.scale.set(0.8, 0.8, 0.8); // Make him a bit smaller

            // Find a random cell that is NOT start or end for Grogu
            let groguX, groguY;
            do {
                groguX = Math.floor(Math.random() * cols);
                groguY = Math.floor(Math.random() * rows);
            } while ((groguX === startNode.x && groguY === startNode.y) || (groguX === endNode.x && groguY === endNode.y));

            groguCell = grid[groguX][groguY]; // Store Grogu's cell reference

            groguMesh.position.set(
                groguX * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX,
                WALL_HEIGHT / 2 + WALL_THICKNESS * 2, // Position him above the floor
                groguY * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY
            );
            scene.add(groguMesh);

            // --- Maze Lamps ---
            // Remove previous lights if they exist
            mazeLights.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            mazeLights = [];

            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1 }); // Glowing lamp
            const lampBulbGeometry = new THREE.SphereGeometry(CELL_SIZE * 0.05, 8, 8);

            for (let i = 0; i < cols; i += 3) { // Place a lamp every 3 columns
                for (let j = 0; j < rows; j += 3) { // Place a lamp every 3 rows
                    const light = new THREE.PointLight(0xffaa00, 0.8, CELL_SIZE * 5); // Warm light, intensity, distance
                    light.position.set(
                        i * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX,
                        WALL_HEIGHT * 0.75, // Position light higher up
                        j * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY
                    );
                    scene.add(light);
                    mazeLights.push(light);

                    // Add a visible bulb for the lamp
                    const lampBulb = new THREE.Mesh(lampBulbGeometry, lightMaterial);
                    lampBulb.position.copy(light.position);
                    scene.add(lampBulb);
                    mazeLights.push(lampBulb); // Add bulb to mazeLights for cleanup
                }
            }


            // Initial render
            renderer.render(scene, camera);

            // Setup and draw mini-map initially
            setupMiniMap();
            drawMiniMapWalls();
            updateMiniMapSolverViz(); // Draw start/end on mini-map
        }

        // --- Mini-Map Functions ---
        function setupMiniMap() {
            miniMapCanvas.width = miniMapCanvas.clientWidth;
            miniMapCanvas.height = miniMapCanvas.clientHeight;
            miniMapW = Math.floor(Math.min(miniMapCanvas.width, miniMapCanvas.height) / Math.max(cols, rows));
            if (miniMapW < 1) miniMapW = 1;
        }

        function drawMiniMapWalls() {
            miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            miniMapCtx.fillStyle = '#000';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            miniMapCtx.strokeStyle = '#8b0000';
            miniMapCtx.lineWidth = 1;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let cell = grid[i][j];
                    let x = cell.x * miniMapW;
                    let y = cell.y * miniMapW;

                    if (cell.walls.top) {
                        miniMapCtx.beginPath();
                        miniMapCtx.moveTo(x, y);
                        miniMapCtx.lineTo(x + miniMapW, y);
                        miniMapCtx.stroke();
                    }
                    if (cell.walls.right) {
                        miniMapCtx.beginPath();
                        miniMapCtx.moveTo(x + miniMapW, y);
                        miniMapCtx.lineTo(x + miniMapW, y + miniMapW);
                        miniMapCtx.stroke();
                    }
                    if (cell.walls.bottom) {
                        miniMapCtx.beginPath();
                        miniMapCtx.moveTo(x + miniMapW, y + miniMapW);
                        miniMapCtx.lineTo(x, y + miniMapW);
                        miniMapCtx.stroke();
                    }
                    if (cell.walls.left) {
                        miniMapCtx.beginPath();
                        miniMapCtx.moveTo(x, y + miniMapW);
                        miniMapCtx.lineTo(x, y);
                        miniMapCtx.stroke();
                    }
                }
            }
        }

        function highlightMiniMapCell(cell, color) {
            let x = cell.x * miniMapW;
            let y = cell.y * miniMapW;
            miniMapCtx.fillStyle = color;
            miniMapCtx.fillRect(x, y, miniMapW, miniMapW);
        }

        function updateMiniMapSolverViz() {
            drawMiniMapWalls();

            for (let i = 0; i < closedSet.length; i++) {
                highlightMiniMapCell(closedSet[i], 'rgba(150, 0, 0, 0.5)');
            }

            for (let i = 0; i < openSet.length; i++) {
                highlightMiniMapCell(openSet[i], 'rgba(255, 0, 0, 0.3)');
            }

            if (groguCell) {
                highlightMiniMapCell(groguCell, '#739D69');
            }

            highlightMiniMapCell(startNode, '#00FF00');
            highlightMiniMapCell(endNode, '#FF00FF');

            if (path.length > 0) {
                miniMapCtx.strokeStyle = '#FFD700';
                miniMapCtx.lineWidth = 2;
                miniMapCtx.beginPath();
                miniMapCtx.moveTo(path[0].x * miniMapW + miniMapW / 2, path[0].y * miniMapW + miniMapW / 2);
                for (let i = 1; i < path.length; i++) {
                    miniMapCtx.lineTo(path[i].x * miniMapW + miniMapW / 2, path[i].y * miniMapW + miniMapW / 2);
                }
                miniMapCtx.stroke();
            }
        }


        // Animation loop for Three.js
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping or controls.autoRotate are set to true
            
            // Update particle system if it exists and path is solved
            if (particleSystem && path.length > 0) {
                const positions = particleSystem.geometry.attributes.position.array;
                const alphas = particleSystem.geometry.attributes.alpha.array;
                const offsets = particleSystem.geometry.attributes.pOffset.array;
                const pathLength = path.length;

                const mazeOffsetX = -(cols * CELL_SIZE) / 2;
                const mazeOffsetY = -(rows * CELL_SIZE) / 2;

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    offsets[i] += PARTICLE_SPEED; // Move particle along its path offset
                    if (offsets[i] >= pathLength - 1) { // If particle reached end of path, reset to start
                        offsets[i] = 0;
                    }

                    // Determine which segment of the path the particle is on
                    const segmentIndex = Math.floor(offsets[i]);
                    const segmentProgress = offsets[i] - segmentIndex;

                    if (segmentIndex < pathLength - 1) {
                        const node1 = path[segmentIndex];
                        const node2 = path[segmentIndex + 1];

                        positions[i * 3 + 0] = node1.x * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX + (node2.x - node1.x) * CELL_SIZE * segmentProgress;
                        positions[i * 3 + 1] = WALL_HEIGHT / 2 + WALL_THICKNESS;
                        positions[i * 3 + 2] = node1.y * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY + (node2.y - node1.y) * CELL_SIZE * segmentProgress;

                        const fadeThreshold = 0.2;
                        if (segmentProgress < fadeThreshold) {
                            alphas[i] = segmentProgress / fadeThreshold;
                        } else if (segmentProgress > (1 - fadeThreshold)) {
                            alphas[i] = (1 - segmentProgress) / fadeThreshold;
                        } else {
                            alphas[i] = 1.0;
                        }
                    } else {
                        const lastNode = path[pathLength - 1];
                        positions[i * 3 + 0] = lastNode.x * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetX;
                        positions[i * 3 + 1] = WALL_HEIGHT / 2 + WALL_THICKNESS;
                        positions[i * 3 + 2] = lastNode.y * CELL_SIZE + CELL_SIZE / 2 + mazeOffsetY;
                        alphas[i] = 0;
                    }
                }

                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.alpha.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // Recursive Backtracking algorithm for maze generation
        function generateMaze3D() {
            statusMessage.textContent = "Generating maze...";
            generateBtn.disabled = true;
            solveBtn.disabled = true;
            stopBtn.disabled = true;
            zoomInBtn.disabled = true;
            zoomOutBtn.disabled = true;


            setupMaze3D();

            let stack = [];
            let current = grid[0][0];
            current.visited = true;
            stack.push(current);

            let generationLoop = setInterval(() => {
                if (stack.length > 0) {
                    current = stack[stack.length - 1]; // Current cell is the top of the stack
                    let next = current.getUnvisitedNeighbors();

                    if (next) {
                        next.visited = true;
                        removeWalls(current, next);
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                } else {
                    clearInterval(generationLoop);
                    statusMessage.textContent = "Maze generated!";
                    generateBtn.disabled = false;
                    solveBtn.disabled = false;
                    zoomInBtn.disabled = false;
                    zoomOutBtn.disabled = false;
                    drawMiniMapWalls();
                    updateMiniMapSolverViz();
                }
            }, 5);
        }
        
        // Heuristic function (Manhattan distance)
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        // Reset pathfinding properties for all cells
        function resetPathfindingProperties() {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    grid[i][j].g = Infinity;
                    grid[i][j].h = 0;
                    grid[i][j].f = Infinity;
                    grid[i][j].parent = undefined;
                    grid[i][j].setFloorMaterial(floorMaterial);
                }
            }
        }

        // A* search algorithm
        function solveMazeStep() {
            if (openSet.length > 0) {
                let lowestFIndex = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[lowestFIndex].f) {
                        lowestFIndex = i;
                    }
                    // Tie-breaking: prefer nodes with lower h-cost (greedy best-first component)
                    if (openSet[i].f === openSet[lowestFIndex].f && openSet[i].h < openSet[lowestFIndex].h) {
                        lowestFIndex = i;
                    }
                }

                let current = openSet[lowestFIndex];
                
                if (current === endNode) {
                    clearInterval(solverInterval);
                    solving = false;
                    
                    // Reconstruct path to end
                    let fullPath = [];
                    let temp = current;
                    while (temp.parent) {
                        fullPath.push(temp);
                        temp = temp.parent;
                    }
                    fullPath.push(startNode);
                    fullPath.reverse();
                    
                    let interceptedByGrogu = false;
                    if (groguCell) {
                        const groguIndex = fullPath.findIndex(cell => cell.x === groguCell.x && cell.y === groguCell.y);
                        if (groguIndex !== -1) {
                            path = fullPath.slice(0, groguIndex + 1);
                            interceptedByGrogu = true;
                        }
                    }

                    if (!interceptedByGrogu) {
                        path = fullPath;
                        statusMessage.textContent = "Path found! May the Force be with you.";
                    } else {
                        statusMessage.textContent = "Path intercepted by Grogu! The way, he has found.";
                    }

                    generateBtn.disabled = false;
                    solveBtn.disabled = false;
                    stopBtn.disabled = true;
                    zoomInBtn.disabled = false;
                    zoomOutBtn.disabled = false;
                    drawPath3D();
                    updateMiniMapSolverViz();
                    return;
                }

                openSet.splice(lowestFIndex, 1);
                closedSet.push(current);

                let neighbors = current.getValidNeighbors();
                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];

                    // If neighbor is already evaluated, skip
                    if (closedSet.includes(neighbor)) {
                        continue;
                    }

                    let tempG = current.g + 1;
                    
                    if (!openSet.includes(neighbor) || tempG < neighbor.g) {
                        neighbor.g = tempG;
                        neighbor.h = heuristic(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = current;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            } else {
                clearInterval(solverInterval);
                solving = false;
                statusMessage.textContent = "No path found! The Force is not strong with this one.";
                generateBtn.disabled = false;
                solveBtn.disabled = false;
                stopBtn.disabled = true;
                zoomInBtn.disabled = false;
                zoomOutBtn.disabled = false;
            }

            drawVisualization3D();
            updateMiniMapSolverViz();
        }

        function drawVisualization3D() {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    grid[i][j].setFloorMaterial(floorMaterial);
                }
            }

            for (let i = 0; i < closedSet.length; i++) {
                closedSet[i].setFloorMaterial(visitedMaterial);
            }

            for (let i = 0; i < openSet.length; i++) {
                openSet[i].setFloorMaterial(openSetMaterial);
            }
        }

        function drawPath3D() {
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
                particleSystem = null;
            }

            if (path.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(particleAlphas, 1));
            geometry.setAttribute('pOffset', new THREE.BufferAttribute(particleOffsets, 1));
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particleOffsets[i] = Math.random() * (path.length - 1);
                particleAlphas[i] = 0;
            }

            particleSystem = new THREE.Points(geometry, particleMaterial);
            particleSystem.name = 'fairyTrail';
            scene.add(particleSystem);
        }
        
        generateBtn.addEventListener('click', generateMaze3D);

        solveBtn.addEventListener('click', () => {
            if (solving) return;

            statusMessage.textContent = "Solving maze...";
            generateBtn.disabled = true;
            solveBtn.disabled = true;
            stopBtn.disabled = false;
            zoomInBtn.disabled = true;
            zoomOutBtn.disabled = true;
            
            resetPathfindingProperties();
            openSet = [];
            closedSet = [];
            path = [];

            startNode.g = 0;
            startNode.h = heuristic(startNode, endNode);
            startNode.f = startNode.g + startNode.h;
            openSet.push(startNode);

            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
                particleSystem = null;
            }

            solving = true;
            solverInterval = setInterval(solveMazeStep, 10);
        });

        stopBtn.addEventListener('click', () => {
            clearInterval(solverInterval);
            solving = false;
            statusMessage.textContent = "Solving stopped.";
            generateBtn.disabled = false;
            solveBtn.disabled = false;
            stopBtn.disabled = true;
            zoomInBtn.disabled = false;
            zoomOutBtn.disabled = false;
            drawVisualization3D();
            updateMiniMapSolverViz();
        });

        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        const ZOOM_STEP_FACTOR = 0.1;
        zoomInBtn.addEventListener('click', () => {
            if (controls && camera) {
                const target = controls.target;
                const currentPosition = camera.position;
                const direction = new THREE.Vector3().subVectors(currentPosition, target).normalize();

                const newDistance = Math.max(controls.minDistance, currentPosition.distanceTo(target) - currentPosition.distanceTo(target) * ZOOM_STEP_FACTOR);
                
                camera.position.copy(target).add(direction.multiplyScalar(newDistance));
                controls.update();
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (controls && camera) {
                const target = controls.target;
                const currentPosition = camera.position;
                const direction = new THREE.Vector3().subVectors(currentPosition, target).normalize();
                const currentDistance = currentPosition.distanceTo(target);

                const newDistance = Math.min(controls.maxDistance, currentDistance + currentDistance * ZOOM_STEP_FACTOR);
                
                camera.position.copy(target).add(direction.multiplyScalar(newDistance));
                controls.update();
            }
        });

        window.onload = () => {
            generateMaze3D();
            animate();
        };

        window.addEventListener('resize', () => {
            const width = threejsContainer.clientWidth;
            const height = threejsContainer.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            setupMiniMap();
            drawMiniMapWalls();
            updateMiniMapSolverViz();

            if (!solving) {
                controls.target.set(
                    -(cols * CELL_SIZE) / 2 + (cols * CELL_SIZE) / 2,
                    0,
                    -(rows * CELL_SIZE) / 2 + (rows * CELL_SIZE) / 2
                );
                controls.update();
            }
        });

        mazeColsInput.addEventListener('change', () => {
            let val = parseInt(mazeColsInput.value);
            if (val < 5) mazeColsInput.value = 5;
            if (val > 30) mazeColsInput.value = 30;
        });
        mazeRowsInput.addEventListener('change', () => {
            let val = parseInt(mazeRowsInput.value);
            if (val < 5) val = 5;
            if (val > 30) val = 30;
            mazeRowsInput.value = val;
        });

    </script>
</body>
</html>
